파티션은 큐를 여러개로 늘려서 병렬 처리가 가능하게 하는 기본 단위이다.
각 토픽은 하나 이상의 파티션으로 구성할 수 있다.
메세지 처리의 순서 보장을 위해서 하나의 파티션은 하나의 컨슈모에만 연결된다. 하지만 하나의 컨슈머는 여러 파티션과 연결 될 수 있다.

파티션 수 늘리는 것은 쉽지만, 줄이는 것은 안된다. 
줄이려면 마이그레이션 해야한다. 


# 분배 방식
1) key가 없는 경우 
   1) round robin -> sticky partitioning 어느 정도 한 파티션에 차야지 그 다음 파티션에 넣어짐. 
   2) 변경 이유는 파티션 하나에 몰아주는 것이 성능적인 이점이 있어서임.  
2) key 값이 있는 경우
   1) key 의 해쉬값으로 파티셔닝한다.  

round robin 방식으로 하려면
```java
spring:
  kafka:
    bootstrap-servers: localhost:9092
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
      properties:
        partitioner.class: org.apache.kafka.clients.producer.RoundRobinPartitioner
```
이렇게 producer application.yaml 에 정의해주면 됩니다. 

서버를 하나 더 킬 때마다, consumer가 구독하는 partition을 재할당한다. 

## 하나의 서버로 병렬 처리하기
```java
@KafkaListener(
      topics = "email.send",
      groupId = "email-send-group",
      concurrency = "3"
  )
```
으로 설정할 경우 하나의 서버만으로도 멀티스레드로 병렬 처리가 가능해진다. 
하나의 컨슈머에 여러 쓰레드가 동작한다. 


# 적정 파티션 수 계산 방법
1. 몇개의 쓰래드를 사용했을 때 가장 처리량이 높아지는지 측정 (100개라 가정)
2. 적정 쓰레드 갯수에서 처리시, 하나의 쓰레드가 처리가능한 양 계산 (100개로 초당 30개씩 처리한다고 가정 -> 하나의 쓰레드 처리량은 0.3)
3. 프로듀서가 보내는 평균 메세지 량 계산 (120개라 가정)
4. 프로듀서가 보내는 평균 메세지 를 모두 처리하기 위해서 필요한 파티션 수 계산(120 = 0.3 * 400, 즉 400개임)

400개가 되어야지 첫번째로 메세지를 할당받은 파티션이 401번째로 할당되는 메세지를 지연없이 처리할 수 있음.
다만 스레드 수가 100→400으로 늘어나면 리소스 경쟁이 생겨 per-thread 처리량이 하락할 수 있습니다.

실제로는 효율계수까지 곱해서 계산함. 0.7~0.9사이로 잡음.
→ 예를 들어 효율계수를 0.8로 보면:

400 * (0.3 * 0.8) = 96 msg/s

# 컨슈머가 메세지를 지연없이 처리하는지 확인하는 방법
- 갑작스러운 요청량 증가 
- 서버 에러 시 

컨슈머 렉이 시간이 갈 수록 쌓여간다면 빠르게 조취를 취해야한다. -> 모니터링 중요 